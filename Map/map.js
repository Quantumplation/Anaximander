var paper, offset, scale;

function getTickList() {
    $.get("http://quantumplation.me:4000/Anaximander", function(data) {
        var select = $("#tick-select");
        var t = select.val();
        select.empty();
        
        var ticks = data.split("\n");
        for (var i in ticks) {
            if (ticks[i])
                select.append("<option value='" + ticks[i] + "'>" + ticks[i] + "</option>");
        }
        
        if (t)
            select.val(t);
        else
            select.children(":last").attr("selected", "selected");
        
        loadAndDraw($("#tick-select").val());
    });
}

function loadAndDraw(tick) {
    if (!tick) return;

    //Data about the universe, obtained from the game
    var stellarData;
    
    //Metadata about the universe, generated by us
    //TODO:: Fetch this from the server (below) instead of hardcoding it
    var strategicData = {
        alliances: {                    //Define what alliances exist
            0: { color: "green" }
        },
        playerAllianceMembership: {     //Define which players are in which alliance
            47: 0, //Quantumplation
            28: 0, //Nyarlathothep
            41: 0, //SolidX
            46: 0, //Pigyman
            62: 0, //Gingervitis
        }
    }
    
    $.getJSON("http://quantumplation.me:4000/Anaximander/" + tick, function(data)
    {
        stellarData = data;
        
        //Get strategic data from server here
        
        draw(stellarData, strategicData);
    });
}

function position(x, y) {
    return [x * scale + offset.x, y * scale + offset.y];
}

function draw(stellarData, strategicData) {
    offset = {"x": document.documentElement.clientWidth / 2, "y": document.documentElement.clientHeight / 2};   
    scale = 100;
    $("svg > g").empty();

    calculateRenderData(stellarData, strategicData);
    
    //drawSensorRange(stellarData, strategicData);      //This makes a total mess of the map
    drawStars(stellarData, strategicData);
    drawFleets(stellarData, strategicData);
}

function calculateRenderData(stellarData, strategicData) {
    for (var pid in stellarData.report.players) {
        var player = stellarData.report.players[pid];
        player.renderData = {
            alliance: strategicData.alliances[strategicData.playerAllianceMembership[player.uid]]
        };
    }
    
    calculatePlayerIcons(stellarData, strategicData);
    calculatePlayerSensorRange(stellarData, strategicData);
}

//go through all players and augment the layer renderdata with player color/icon
function calculatePlayerIcons(stellarData, strategicData) {
    for (var pid in stellarData.report.players) {
        var player = stellarData.report.players[pid];

        if (player.ai == 1 || player.conceded == 1) { //Conceded check might be pointless, all conceded players are AIs?
            player.renderData.color = "hotpink";
        } else {        
            if (player.renderData.alliance != undefined) {
                player.renderData.color = player.renderData.alliance.color;
            } else {
                player.renderData.color = "gray";
            }
        }
    }
}

function calculatePlayerSensorRange(stellarData, strategicData) {
    for (var pid in stellarData.report.players) {
        var player = stellarData.report.players[pid];
        var sensorTechLevel = player.tech.scanning.level;
        var sensorRange = sensorTechLevel + 2;
        
        player.renderData.sensorRange = sensorRange;
    }
}

//This is a little difficult, we really want multiple layers
//layers can be done with raphael by using multiple different Raphael objects (http://stackoverflow.com/questions/5556421/how-to-create-multiple-layer-images-using-raphael-canvas-library)
//so maybe that should be done sometime
function drawSensorRange(stellarData, strategicData) {
    for (var i in stellarData.report.stars) {
        var star = stellarData.report.stars[i];
        
        if (star.puid == -1)
            continue;
            
        var player = stellarData.report.players[star.puid];
        var sensorRange = player.renderData.sensorRange / 10;
        var pos = position(star.x, star.y);
        
        paper.circle(pos[0], pos[1], sensorRange * scale)
            .attr({"stroke": "gray", "stroke-width": "1"});
    }
}

function drawStars(stellarData, strategicData) {
    for (var i in stellarData.report.stars) {
        var star = stellarData.report.stars[i];
        
        var color;
        if (star.puid == -1)                                                        //If the star is not owned then render is as either visible or not
            color = star.v == "0" ? "black" : "white";
        else                                                                        //If the star *is* owned, draw it with player colors (and icon, when that's done)
            color = stellarData.report.players[star.puid].renderData.color;
        
        var pos = position(star.x, star.y);
        paper.circle(pos[0], pos[1], 0.03 * scale)
            .attr({"stroke": "gray", "stroke-width": "1", "fill": color});
    }
}

function drawFleets(stellarData, strategicData) {
    for (var i in stellarData.report.fleets) {
        var fleet = stellarData.report.fleets[i];
        
        //Orders is an array of arrays, a bit like this:
        //"o": [ [0,804,7,1],[0,865,7,1],[0,675,7,1]]
        //It looks like the elements are:
        // - No idea! This is zero for every fleet I've ever seen
        // - Star id
        // - *Possibly* an enum value for the action to carry out on this star
        // - Assuming the above is correct, probably a value for the enum (i.e. my example fleet above is set to garrison 1)
        var orders = fleet.o;
        
        if (orders.length == 0)
            continue;
            
        var positions = [];
        positions.push(position(fleet.x, fleet.y));
        for (var o in orders) {
            var order = orders[o];
            var star = stellarData.report.stars[order[1]];
            positions.push(position(star.x, star.y));
        }
        
        var path = "M" + positions[0][0] + " " + positions[0][1];
        for (var o = 1; o < positions.length; o++) {
            var dx = positions[o - 1][0] - positions[o][0];
            var dy = positions[o - 1][1] - positions[o][1];
            path += "L" + dx + " " + dy;
        }
    }
}

$(function() {
    paper = Raphael("container");
    
    //This ZPD thing is really ugly.
    //It's flagging deprecated event usage, using paper.clear breaks it, and it has no way to programatically set the zoom as far as I can see
    new RaphaelZPD(paper, { zoom: true, pan: true, drag: false });
    
    // fuck you raphael
    var svg = document.querySelector("svg");
    svg.removeAttribute("width");
    svg.removeAttribute("height");
    svg.style.width = "100vw";
    svg.style.height = "100vh";
    
    getTickList();
    $("#reload").click(getTickList);
});